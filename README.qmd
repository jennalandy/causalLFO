---
title: "`causalLFO`: R package for\nCausal Inference for Latent Factor-Modeled Outcomes"
format: gfm
---

This R package provides all algorithms discussed in the paper "Causal Inference for Latent Factor-Modeled Outcomes". Code to reproduce results from our paper can be found in the [jennalandy/causalLFO_PAPER](https://github.com/jennalandy/causalLFO_PAPER/tree/master) repository.

## Installation

```{r eval = FALSE}
remotes::install_github("jennalandy/causalLFO")
```

```{r message = FALSE}
library(NMF)
library(causalLFO)
```

`NMF::nmf()` internally uses `setupLibPaths("NMF")`, which calls `path.package("NMF")`. This requires the NMF package to be attached, not just imported, so the user must library `NMF` as well as `causalLFO`.

Please install `NMF` if you have not yet done so. `NMF` requires the `Biobase` package, which may have to be installed separately from `Bioconductor`.

## Quick Start

This code block simulates a simple dataset with 100 samples, three latent factors, and a true ATE of 300 on the first latent dimension.
```{r}
N = 100; D = 96; K = 3; ATE = c(300, 0, 0)

# Simulate treatment assignment
Tr = sample(c(0, 1), N, replace = TRUE)

# Simulate latent factors P
true_P = matrix(rexp(D*K, rate = 1), nrow = D)
# Normalize factors to sum to 1
true_P = sweep(true_P, 2, colSums(true_P), '/')

# Simulate untreated factor loadings C
true_C = matrix(rexp(K*N, rate = 0.01), nrow = K)
# Add ATE to loadigns of treated samples
for (k in 1:K) {
  true_C[k, Tr == 1] <- true_C[k, Tr == 1] + ATE[k]
}

# Simulate M ~ Poisson(PC)
M = matrix(nrow = D, ncol = N)
for (i in 1:N) {
  M[,i] <- rpois(D, lambda = true_P %*% true_C[,i])
}
```

### Run impute and stabilize algorithm once to yield a point estimate. 

```{r}
impute_and_stabilize_res <- impute_and_stabilize(
  M, Tr, rank = 3, reference_P = true_P
)
class(impute_and_stabilize_res)
summary(impute_and_stabilize_res)
plot(impute_and_stabilize_res)
```

If you have multiple sets of results, they can be plotted together with `plot_causalLFO_results`. This could be from multiple algorithms as we have here, or alternatively from multiple datasets.
```{r}
all_data_res <- all_data(
  M, Tr, rank = 3, reference_P = true_P
)
res_list <- list(
  'All Data' = all_data_res,
  'Impute and Stabilize' = impute_and_stabilize_res
)
plot_causalLFO_results(res_list)
```



### Run impute and stabilize algorithm with bootstrap resampling to estimate a 95% confidence interval.

When `bootstrap = TRUE`, any of the `causalLFO` algorithms will create three files named according to the `bootstrap_filename` parameter: `examples/impute_and_stabilize.csv` with ATE estimates from each of the 500 bootstrap replicates, `examples/impute_and_stabilize_aligned_Ps.rds` with a list of all 500 aligned factor matrices. We also choose to save the `res` object to a separate `.rds` file for easy access at a later time, and `examples/impute_and_stabilize_res.rds` with the full results object that is also returned by the function

```{r eval = FALSE}
impute_and_stabilize_bootstrap_res <- impute_and_stabilize(
  M, Tr, rank = 3, reference_P = true_P,
  bootstrap = TRUE, bootstrap_reps = 30,
  bootstrap_filename = "examples/impute_and_stabilize"
  # small bootstrap_reps for demonstration purposes only
  # we recommend default bootstrap_reps = 500
)
```

When `bootstrap = TRUE`, the `class` is changed from `causalLFO_result` to `causalLFO_bootstrap_result`, resulting in updated `summary` and `plot` methods:

```{r}
impute_and_stabilize_bootstrap_res <- readRDS("examples/impute_and_stabilize_res.rds")
class(impute_and_stabilize_bootstrap_res)
summary(impute_and_stabilize_bootstrap_res)
plot(impute_and_stabilize_bootstrap_res)
```

Again, multiple sets of results can be plotted together with `plot_causalLFO_bootstrap_results`.

```{r eval = FALSE}
all_data_bootstrap_res <- all_data(
  M, Tr, rank = 3, reference_P = true_P,
  bootstrap = TRUE, bootstrap_reps = 30,
  bootstrap_filename = "examples/all_data"
  # small bootstrap_reps for demonstration purposes only
  # we recommend default bootstrap_reps = 500
)
```

```{r}
all_data_bootstrap_res <- readRDS("examples/all_data_res.rds")
res_list <- list(
  'All Data' = all_data_bootstrap_res,
  'Impute and Stabilize' = impute_and_stabilize_bootstrap_res
)
plot_causalLFO_bootstrap_results(res_list)
```

## Algorithms

This section follows the notation of the paper "Causal Inference for Latent Factor-Modeled Outcomes". Please refer to sections 2 and 3 for details.

The primary algorithm provided by this package is the `impute_and_stabilize` algorithm proposed in the paper "Causal Inference for Latent Factor-Modeled Outcomes". We first estimate unobserved potential outcomes $\mathbf Y(1-\mathbf T)$ with imputations $\tilde{\mathbf Y}_{1-\mathbf T}$. We fit the factor model $\hat{\boldsymbol \lambda}$ on a matrix of the original sample size $\tilde{\mathbf Y}_{\mathbf 0}$ as a combination of observed (for $T_i = 0$) and imputed (for $T_i = 1$) values to estimate $\ell_{\text{IS}, 0}(Y_i, T_i)$. A non-negative linear model is then used on the remaining $\tilde{\mathbf Y}_{1}$ with fixed $\hat{\boldsymbol \lambda}$ to measure $\ell_{\text{IS}, 1}(Y_i, T_i)$. Pairwise comparisons are used to estimate ATE with a mean of individual treatment effects estimator.

We also provide two baselines for comparison. First, `all_data` uses the full dataset $\mathbf Y$ to perform matrix decomposition to estimate $\hat{\boldsymbol \lambda}$ and $\ell_{\text{AD}, T_i}(Y_i, T_i)$, then again the full dataset to estimate causal effects with difference of means on $\ell_{\text{AD}, T_i}(Y_i, T_i)$. Second, we consider the `random_split` approach suggested by prior literature: identify a random subset of 50% of indices $S$, use $\mathbf Y_S$ as input to matrix decomposition to estimate $\hat{\boldsymbol \lambda}$, use a non-negative linear model on remaining data $\mathbf Y_{/S}$ to estimate latent outcomes $\ell_{\text{RS}, T_i}(Y_i, T_i)$ for $i \notin S$, and finally estimating the ATE with difference of means on those estimates.

Finally, we provide two ablations of the novel Impute and Stabilize algorithm to identify the relative benefits of each component. In the `impute` ablation, we perform imputation as before, but we perform matrix decomposition on the observed data $\mathbf Y$ to estimate $\ell_{\text{I}, T_i}(Y_i, T_i)$ for observed $T_i$ and non-negative linear model on the imputed $\tilde{\mathbf Y}_{1-\mathbf T}$ to estimate $\ell_{\text{I}, 1-T_i}(Y_i, T_i)$ for unobserved $T_i$. In the `stabilize` ablation, we perform matrix decomposition only on the untreated subset of observed data $\mathbf Y_{\{i:T_i = 0\}}$ and non-negative linear model on the treated subset $\mathbf Y_{\{i:T_i = 1\}}$, and a simple difference of means is used on the estimated latent outcomes $\ell_{\text{S}, T_i}(Y_i, T_i)$.
